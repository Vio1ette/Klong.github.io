<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="再勇敢一点，再自信一点" />
  

  
  
  
  
  
  
  <title>Klong&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="再勇敢一点，再自信一点">
<meta property="og:type" content="website">
<meta property="og:title" content="Klong&#39;s Blog">
<meta property="og:url" content="http://example.com/page/9/index.html">
<meta property="og:site_name" content="Klong&#39;s Blog">
<meta property="og:description" content="再勇敢一点，再自信一点">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="pano">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
<meta name="generator" content="Hexo 6.0.0"></head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="Klong&#39;s Blog" rel="home">Klong&#39;s Blog</a>
      </h1>
      
        <h2 class="site-description hitokoto"></h2>
        <script type="text/javascript" src="https://v1.hitokoto.cn/?encode=js"></script>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-英语/定语从句专题" class="post-英语/定语从句专题 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2021/12/20/%E8%8B%B1%E8%AF%AD/%E5%AE%9A%E8%AF%AD%E4%BB%8E%E5%8F%A5%E4%B8%93%E9%A2%98/">【专题】定语从句</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://example.com/2021/12/20/%E8%8B%B1%E8%AF%AD/%E5%AE%9A%E8%AF%AD%E4%BB%8E%E5%8F%A5%E4%B8%93%E9%A2%98/" data-id="cl829mimh000hssv5591c42k9" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>什么是定语从句？</p>
<p>用一句话作定语，通常用来修饰名词、代词，被修饰的词称为<code>先行词</code></p>
<h3 id="一、限制性定语从句"><a href="#一、限制性定语从句" class="headerlink" title="一、限制性定语从句"></a>一、限制性定语从句</h3><p>引导词<strong>代替先行词</strong>，在定语从句<strong>充当成分</strong></p>
<blockquote>
<p>对比宾语从句中，<code>that</code>不充当任何成分，可以省略</p>
</blockquote>
<h4 id="1-关系代词："><a href="#1-关系代词：" class="headerlink" title="1. 关系代词："></a>1. 关系代词：</h4><ul>
<li><p>指代<strong>人</strong>：<code>who</code>（在从句中充当主语、宾语）、<code>whom</code>（充当宾语）</p>
<p>The man <code>who(that) robbed him</code> has been arrested.</p>
<p>The girl <code>whom I saw</code> told me to come back today.</p>
<p>The friend <code>with whom I was traveling</code> spoke French.</p>
</li>
<li><p>指代<strong>物</strong>：<code>which</code>（主、宾）</p>
<p>The car <code>which (that) I hired</code> broke down.</p>
<p>I don’t like the novel <code>which you are reading</code>.</p>
</li>
<li><p>指代<strong>人或物</strong>：<code>that</code>（主、宾），<code>whose</code>（定语，意思是<code>谁的</code>）</p>
<p>I like the girl <code>whose eyes are very big</code>.</p>
</li>
</ul>
<h4 id="2-关系副词："><a href="#2-关系副词：" class="headerlink" title="2. 关系副词："></a>2. 关系副词：</h4><ul>
<li><p><code>when</code>（时间状语）：指代<strong>时间</strong></p>
<p>At the time <code>when</code> I saw him, he was quite strong.</p>
<p>I will never forget the day <code>when (on which)</code> I came to Beijing.</p>
</li>
<li><p>where<code>（地点状语）：表示地点</code></p>
<p>This is the village <code>where</code> I was born.</p>
<p>The police searched the house <code>where (in which)</code> he lived.</p>
</li>
<li><p><code>why</code>（原因状语）：<code>why</code>的先行词只能是<code>reason</code></p>
<p>I don’t know the reason <code>why (for which)</code> he is angry.</p>
</li>
</ul>
<h3 id="3-省略"><a href="#3-省略" class="headerlink" title="3. 省略"></a>3. 省略</h3><ul>
<li><p>在<strong>限制性定语从句</strong>中，当关系代词在从句中作<strong>宾语</strong>时，一般都可以<strong>省略</strong></p>
<p>Have you got everything (<code>that</code>) you need?</p>
<p>That’s the only thing (<code>that</code>) we can do now.</p>
<p>You can take any room (<code>that</code>) you like.</p>
</li>
<li><p><strong>口语</strong>中，在从句作<strong>主语</strong>也可以<strong>省略</strong></p>
<p>There’s a strange man (<code>that</code>) lives in that small village.</p>
<p>There’s something (<code>that</code>) keeps worrying me.</p>
</li>
</ul>
<h4 id="4-有些表示时间的定语从句并不由when引导"><a href="#4-有些表示时间的定语从句并不由when引导" class="headerlink" title="4. 有些表示时间的定语从句并不由when引导"></a>4. 有些表示时间的定语从句并不由when引导</h4><p>This was the first <code>time</code> I had serious trouble with my boss.</p>
<p>Every <code>time</code> the telephone rings, he gets nervous.</p>
<h4 id="5-way后也可跟定语从句，不需要关系代词或副词"><a href="#5-way后也可跟定语从句，不需要关系代词或副词" class="headerlink" title="5. way后也可跟定语从句，不需要关系代词或副词"></a>5. way后也可跟定语从句，不需要关系代词或副词</h4><p>I didn’t like the way he eyed me. 【应该是方式状语？】</p>
<h3 id="二、非限制性定语从句"><a href="#二、非限制性定语从句" class="headerlink" title="二、非限制性定语从句"></a>二、非限制性定语从句</h3><p><strong>非限制性定语从句</strong>对所修饰的词没有限制词义的作用，而只是补充说明，通常都有逗号，译成中文时，多翻译为并列句</p>
<p>限制性定语从句拿掉以后，句子意思常发生变化。而<strong>非限制性定语</strong>从句拿掉以后，对剩下部分没有太大影响</p>
<blockquote>
<p>注意非限制性定语从句中<strong>不能</strong>使用<strong>关系代词 that</strong> 和<strong>关系副词 why</strong>，也<strong>不能</strong>省略任何关系副词</p>
</blockquote>
<p>Peter, <code>who</code> had been driving all day, suggested stopping at the next town.</p>
<p>Paul, <code>whom</code> everyone suspected, turned out to be innocent.</p>
<p>The 9:30 train, <code>which</code> is usually very punctual, was late today.</p>
<p>Sunday is a holiday, <code>when</code> people do not go to work.</p>
<h4 id="非限制性定语从句中，which-和-whom-和-of-或其他介词连用"><a href="#非限制性定语从句中，which-和-whom-和-of-或其他介词连用" class="headerlink" title="非限制性定语从句中，which 和 whom 和 of 或其他介词连用"></a>非限制性定语从句中，which 和 whom 和 of 或其他介词连用</h4><p>The buses, <code>most of which</code> were already full, were surrounded by an angry crowd.</p>
<p>She had eight children, <code>three of whom</code> lived to grow up. ( three of whom 在从句中作主语 )</p>
<p>Her sons, <code>both of whom</code> work abroad, ring her up every week. </p>
<p>I met the fruit-pickers, <code>several of whom</code> were college students.</p>
<h4 id="which-有时代表一个句子"><a href="#which-有时代表一个句子" class="headerlink" title="which 有时代表一个句子"></a>which 有时代表一个句子</h4><p>They rely on themselves, <code>which</code> is much better.</p>
<p>He invited us to dinner, <code>which</code> was very kind of him.</p>
<p>He changed his mind, <code>which</code> made me very angry.</p>
<p>She was very patient towards the children, <code>which</code> her husband seldom was. </p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2021/12/20/%E8%8B%B1%E8%AF%AD/%E5%AE%9A%E8%AF%AD%E4%BB%8E%E5%8F%A5%E4%B8%93%E9%A2%98/">
    <time datetime="2021-12-19T16:00:00.000Z" class="entry-date">
        2021-12-20
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/English/">English</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Grammar/" rel="tag">Grammar</a></li></ul>

    </footer>
</article>






  
    <article id="post-C++/拷贝控制/拷贝初始化" class="post-C++/拷贝控制/拷贝初始化 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2021/11/24/C++/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96/">拷贝初始化那些事儿</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://example.com/2021/11/24/C++/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96/" data-id="cl829mimp0015ssv58ask4dt1" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>要么只有一个参数，此参数是自身类类型的常引用，要么多个参数，第一个参数为自身类类型的常引用，其他参数都有默认值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>();</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="keyword">const</span>  Foo&amp;);  <span class="comment">//可以用初始化列表，或在花括号里一一拷贝</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="合成拷贝构造函数"><a href="#合成拷贝构造函数" class="headerlink" title="合成拷贝构造函数"></a>合成拷贝构造函数</h3><p>如果用户没有为类定义一个拷贝构造函数，编译器会自动生成一个，执行<strong>浅拷贝</strong>，依次拷贝每个非 <code>static</code> 成员</p>
<h3 id="直接初始化（无-号）"><a href="#直接初始化（无-号）" class="headerlink" title="直接初始化（无=号）"></a>直接初始化（无<code>=</code>号）</h3><p>匹配最佳的构造函数（注意也有可能匹配上拷贝构造函数）</p>
<h3 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h3><p>使用拷贝初始化的常见四种情况：</p>
<ol>
<li><code>=</code>号</li>
<li>函数非引用形参</li>
<li>函数非引用返回类型 </li>
<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li>
</ol>
<p>拷贝初始化有时候会使用<strong>移动构造函数</strong>而非<strong>拷贝构造函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(Foo &amp;&amp;f)&#123;&#125; <span class="comment">//移动构造函数</span></span><br><span class="line">    Foo&amp; <span class="keyword">operator</span>=(Foo f)&#123;&#125; <span class="comment">//普通左值既可以接受左值也可以接受右值，反正都是要拷贝的</span></span><br><span class="line">    <span class="comment">//注意上面这个不是拷贝赋值运算符，拷贝赋值运算符要求参数为常引用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>观察：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo&amp; <span class="keyword">operator</span>=(Foo f)&#123;&#125; <span class="comment">//单一的赋值运算符实现了拷贝赋值运算符和移动赋值运算符两种可能</span></span><br></pre></td></tr></table></figure>

<p>此运算符有一个<u>非引用</u>参数，所以要进行<u>拷贝初始化</u></p>
<p>依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——<u>左值</u>被拷贝，<u>右值</u>被移动</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hp = hp2; 				<span class="comment">//拷贝构造函数来拷贝hp2</span></span><br><span class="line">hp = std::<span class="built_in">move</span>(hp2);    <span class="comment">//移动构造函数移动hp2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>有点奇怪，按理说=号赋值应该调用拷贝赋值运算符，这里却调用那个非拷贝赋值运算符？</p>
</blockquote>
<h3 id="为什么拷贝构造函数自己的参数必须是引用类型？"><a href="#为什么拷贝构造函数自己的参数必须是引用类型？" class="headerlink" title="为什么拷贝构造函数自己的参数必须是引用类型？"></a>为什么拷贝构造函数自己的参数必须是引用类型？</h3><p>如果不是引用，则会调用拷贝构造函数，形成拷贝构造函数调用拷贝构造函数的死循环</p>
<h3 id="编译器可以绕过拷贝-移动构造函数"><a href="#编译器可以绕过拷贝-移动构造函数" class="headerlink" title="编译器可以绕过拷贝/移动构造函数"></a>编译器可以绕过拷贝/移动构造函数</h3><p>拷贝初始化中，编译器可以选择跳过拷贝/移动构造函数，直接创建对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string null_book = <span class="string">&quot;9999&quot;</span>; <span class="comment">//拷贝初始化</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>隐式类型转换（转换构造函数）</strong>：只接受一个实参，或者其他参数都有默认参数</p>
<p>在需要类对象的时候，编译器可以根据已经有的一个参数，调用转换构造函数，自动创建一个（临时）对象</p>
</blockquote>
<p>正常来讲，字符串字面值<code>&quot;9999&quot;</code> 是<code>const char*</code>类型，由于要进行拷贝初始化，<code>=</code>号右边需要一个<code>string</code>对象，所以根据<strong>隐式类型转换</strong>，在需要<code>string</code>对象的时候，可以调用相应的<strong>转换构造函数</strong>，自动创建一个临时<code>string</code>对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> (<span class="keyword">const</span> <span class="keyword">char</span>* s); <span class="comment">//from c-string (4)	转换构造函数</span></span><br></pre></td></tr></table></figure>

<p>有了临时<code>string</code>对象后，按理说要调用拷贝构造函数，完成对<code>null_book</code>的拷贝初始化</p>
<p>然而，这里<strong>并没有</strong>调用拷贝构造函数，经测试<strong>也没有</strong>调用移动构造函数，原因是编译器对拷贝初始化表达式进行了改写</p>
<p>把</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string null_book = <span class="string">&quot;9999&quot;</span>; <span class="comment">//拷贝初始化</span></span><br></pre></td></tr></table></figure>

<p>改写为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">null_book</span><span class="params">(<span class="string">&quot;9999&quot;</span>)</span></span>; <span class="comment">// 使临时对象成为要创建的对象</span></span><br></pre></td></tr></table></figure>

<p>按理说被改写后应该属于（调用拷贝构造函数的）直接初始化</p>
<p>但是在利用转换构造函数生成临时<code>string</code>对象后</p>
<p>编译器直接使临时对象成为要创建的对象（编译器优化），所以没有调用拷贝/移动构造函数</p>
<p>其他例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="keyword">const</span> Foo&amp; other) :<span class="built_in">len</span>(other.len) &#123; cout &lt;&lt; <span class="string">&quot;拷贝构造函数！&quot;</span> &lt;&lt; endl; &#125;  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Foo</span>(<span class="keyword">int</span> length) :<span class="built_in">len</span>(length) &#123; cout &lt;&lt; <span class="string">&quot;转换构造函数&quot;</span> &lt;&lt; endl; &#125; 		       <span class="comment">//转换构造函数</span></span><br><span class="line">    <span class="built_in">Foo</span>(Foo&amp;&amp;) &#123; cout &lt;&lt; <span class="string">&quot;移动构造函数&quot;</span> &lt;&lt; endl; &#125; 							   <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="function">Foo&amp; <span class="title">temp_f</span><span class="params">(Foo temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Foo c1 = <span class="number">10</span>; <span class="comment">//本身为拷贝初始化，编译器将其改写为下一行的语句，不会调用拷贝/移动构造函数！</span></span><br><span class="line">    <span class="function">Foo <span class="title">c</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">//不会调用拷贝/移动构造函数！只会调用转换构造函数</span></span><br><span class="line">    c.<span class="built_in">temp_f</span>(<span class="number">10</span>); <span class="comment">// 虽然形参非引用，但是也不会调用拷贝/移动构造函数！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析一下这个：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">temp_f</span>(<span class="number">10</span>); <span class="comment">// 虽然形参非引用，但是也不会调用拷贝/移动构造函数！</span></span><br></pre></td></tr></table></figure>

<p>形参非引用，参数<code>10</code>被作为参数传入，先会调用转换构造函数，使<code>10</code>被隐式转换为一个<code>Foo临时对象</code></p>
<p>注意，这个对象是临时的，临时量具有<u>常量性</u>（<code>const</code>属性）</p>
<p><u>常量性</u>意味着：</p>
<ol>
<li><p>如果<code>temp_f</code>的形参是<code>左值引用&amp;</code>，将会报错，左值<u>引用</u>不能接受一个<code>const</code>值，左值引用也不能接受一个右值</p>
</li>
<li><p>如果<code>temp_f</code>的形参是<code>常量左值引用const &amp;</code>或<code>右值引用&amp;&amp;</code>，不会报错，因为它们都可以接受一个右值，而且因为是引用了，所以也不会调用拷贝构造函数</p>
</li>
<li><p>如果<code>temp_f</code>的形参是<code>普通左值</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Foo&amp; <span class="title">temp_f</span><span class="params">(Foo temp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>普通左值可以接受<code>const值</code>或<code>右值</code>，因为这就直接<u>拷贝</u>了，<code>const值</code>或<code>右值</code>没有被改变的风险</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;<span class="keyword">const</span> <span class="keyword">int</span> ci = i;<span class="keyword">int</span> j = ci;  <span class="comment">// ci的常量特征仅仅在执行改变ci的操作时才会发挥作用，一旦拷贝完成，新的对象就和原来的对象没什么关系了</span></span><br></pre></td></tr></table></figure>

<p>然后按理来说，函数形参非引用，应该是个拷贝初始化，调用拷贝构造函数</p>
<p>但是没有！因为传给 temp_f 是一个<strong>匿名临时对象</strong>！</p>
<p>只有一个对象对另一个同类型的对象进行初始化才会调用拷贝构造函数，但是<u>匿名对象对另一个同类型的对象初始化<strong>不会</strong>调用拷贝构造函数</u>，因为c++<strong>编译器</strong>对这种情况进行<strong>优化</strong>，<u>直接将匿名对象转化为该对象</u>，不需要进行额外的内存分配，提高了效率；</p>
<p>编译器在此时进行了优化，<u>绕过了拷贝/移动构造函数</u>，将<code>Foo临时对象</code>直接创建了<code>Foo对象</code>作为形参，所以并没有调用拷贝/移动构造函数！</p>
<p>参考解析：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weicao1990/article/details/81629955">https://blog.csdn.net/weicao1990/article/details/81629955</a></p>
<blockquote>
<p>即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是可存在且可访问的（必须是<code>public</code>的，不能是<code>private</code>）</p>
</blockquote>
</li>
</ol>
<h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><p>注意区分赋值和初始化</p>
<p>返回类型为<u>引用</u>，形参为<u>常引用</u>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;); <span class="comment">//赋值运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>拷贝赋值运算符=重载赋值运算符</p>
<p>重载赋值运算符的参数表示运算符的<strong>运算对象</strong></p>
<p>如果一个运算符是成员函数（<strong>赋值运算符必须定义为成员函数</strong>），则其第一个参数肯定是<strong>隐式this参数</strong>，这也是该运算符的（<strong>左侧</strong>）运算对象</p>
<ul>
<li>如果是一元运算符，就只有这一个运算对象</li>
<li>如果是二元运算符（例如赋值运算符），其<strong>右侧</strong>运算对象作为<strong>显示</strong>参数传递</li>
</ul>
</blockquote>
<p>如果类没有定义自己的拷贝赋值运算符，编译器会自动合成一个合成拷贝赋值运算符</p>
<p>但是<strong>合成拷贝赋值运算符</strong>实行<strong>浅</strong>拷贝，当对象中存在指针成员变量时，存在如下问题：</p>
<p><img src="https://raw.githubusercontent.com/Vio1ette/blog-img/main/image-20211124194517073.png" alt="原生赋值运算符"></p>
<p>所以当对象中存在指针成员变量， 应该自定义新的拷贝赋值构造函数，执行<strong>深</strong>拷贝</p>
<h3 id="2-对象移动"><a href="#2-对象移动" class="headerlink" title="2. 对象移动"></a>2. 对象移动</h3><h4 id="2-1-右值引用"><a href="#2-1-右值引用" class="headerlink" title="2.1 右值引用"></a>2.1 右值引用</h4><p>符号：<code>&amp;&amp;</code></p>
<p><strong>右值引用</strong>只能绑定到一个将要销毁的对象（临时对象）</p>
<p><strong>左值引用</strong>不能被绑定到要求转换的表达式，字面常量或是返回右值的表达式，但<u>右值引用可以</u>，但不能将一个右值引用直接绑定到一个左值上</p>
<ul>
<li>返回左值的表达式（可以被<code>左值引用</code>绑定）：返回左值引用的函数，包括赋值、下标、解引用和前置递增/递减运算符</li>
<li>返回右值的表达式（可以被<code>const左值引用</code>、<code>右值引用&amp;&amp;</code>绑定）：返回非引用类型的函数，包括算数、关系、位以及后置递增/递减运算符</li>
</ul>
<p>变量是持久的，包括右值引用类型的左值，所以<u>不能将一个右值引用绑定到一个右值引用类型的变量上</u>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = rr1; <span class="comment">//错误！变量表达式 rr1 是左值</span></span><br></pre></td></tr></table></figure>

<p><code>std::move</code>显示地将左值转变为右值</p>
<h4 id="2-2-移动构造函数（移动语义）"><a href="#2-2-移动构造函数（移动语义）" class="headerlink" title="2.2 移动构造函数（移动语义）"></a>2.2 移动构造函数（移动语义）</h4><p>以移动而非深拷贝的方式初始化含有指针成员的类对象</p>
<p>移动构造函数的第一个参数为右值引用，任何额外的参数都必须有默认实参</p>
<ol>
<li>指针资源交接</li>
<li>原来的指针应该指向<code>nullptr</code></li>
</ol>
<p>浅拷贝+销毁=移动</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">demo</span>(<span class="keyword">const</span> demo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*d.num))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加移动构造函数</span></span><br><span class="line">    <span class="built_in">demo</span>(demo &amp;&amp;d):<span class="built_in">num</span>(d.num)&#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">demo</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;class destruct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">demo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = <span class="built_in">get_demo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果：为 demo 类添加移动构造函数之后，使用临时对象初始化 a 对象过程中产生的 2 次拷贝操作，都由移动构造函数完成</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当类中同时包含拷贝构造函数和移动构造函数时，如果使用<strong>临时对象</strong>初始化当前类的对象，编译器会<strong>优先调用移动构造函数</strong>来完成此操作。</p>
<p>只有当类中没有合适的移动构造函数时，编译器才会退而求其次，用拷贝构造函数<strong>代替</strong>移动构造函数（赋值运算符的情况类类似）</p>
</blockquote>
<h4 id="2-3-移动赋值运算符"><a href="#2-3-移动赋值运算符" class="headerlink" title="2.3 移动赋值运算符"></a>2.3 移动赋值运算符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">StrVec&amp; StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) &#123;</span><br><span class="line">    <span class="comment">//直接检测自赋值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) &#123; <span class="comment">//rhs是个右值引用变量表达式，所以它是个左值，所以可以对它取地址</span></span><br><span class="line">        <span class="built_in">free</span>();    		<span class="comment">//释放已有元素</span></span><br><span class="line">        elements = rhs.elements; <span class="comment">// 从rhs接管资源</span></span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">        cap = rhs.cap;</span><br><span class="line">        <span class="comment">// 将rhs置于可析构状态</span></span><br><span class="line">        rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-合成的移动操作"><a href="#2-4-合成的移动操作" class="headerlink" title="2.4 合成的移动操作"></a>2.4 合成的移动操作</h4><p>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就<strong>不会自动合成</strong>移动构造函数和移动赋值运算符</p>
<p>仅当一个类没有定义任何自己版本的拷贝控制成员（三大件），且类的每个非static数据成员都可以移动时，编译器才会自动合成移动构造函数或移动赋值运算符</p>
<p>可移动：</p>
<ul>
<li>内置类型总是可移动的</li>
<li>类类型，要求该类有对应的移动操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译器会为X和hasX合成移动操作</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;  			<span class="comment">//内置类型可以移动</span></span><br><span class="line">    std::string s; 		<span class="comment">//string定义了自己的移动操作</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hasX</span> &#123;</span></span><br><span class="line">    X mem;				<span class="comment">// X有合成的移动操作</span></span><br><span class="line">&#125;;</span><br><span class="line">X x, x2 = std::<span class="built_in">move</span>(x); 	  <span class="comment">//使用合成的移动构造操作</span></span><br><span class="line">hasX hx, hx2 = std::<span class="built_in">move</span>(hx); <span class="comment">//使用合成的移动构造函数</span></span><br></pre></td></tr></table></figure>






      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2021/11/24/C++/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96/">
    <time datetime="2021-11-23T16:00:00.000Z" class="entry-date">
        2021-11-24
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E8%8F%9C/">我为什么这么菜~~</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/" rel="tag">C&#x2F;C++</a></li></ul>

    </footer>
</article>






  
    <article id="post-英语/虚拟语气专题" class="post-英语/虚拟语气专题 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2021/11/13/%E8%8B%B1%E8%AF%AD/%E8%99%9A%E6%8B%9F%E8%AF%AD%E6%B0%94%E4%B8%93%E9%A2%98/">【专题】虚拟语气</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://example.com/2021/11/13/%E8%8B%B1%E8%AF%AD/%E8%99%9A%E6%8B%9F%E8%AF%AD%E6%B0%94%E4%B8%93%E9%A2%98/" data-id="cl829mimj000lssv5ecne2t9b" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>虚拟语气在形式上分为三类</p>
<ol>
<li><p><strong>现在</strong>虚拟语气——动词原形</p>
<p><em>God <code>bless</code> you.</em> </p>
</li>
<li><p><strong>过去</strong>虚拟语气——和陈述语气的过去时相同，但动词 <code>be</code> 要用 <code>were</code></p>
<p><em>If only I <code>were</code> not so nervous. // 我要是不那么紧张就好了</em></p>
<p><em>She treated me as though I <code>were</code> a stranger.</em></p>
</li>
<li><p><strong>过去完成</strong>形式——和陈述语气中的过去完成时相同</p>
<p><em>I wish I <code>hadn&#39;t done</code> so.</em></p>
<p><em>If only I <code>had listened</code> to your advice.</em></p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://dictionary.cambridge.org/grammar/british-grammar/if-only">If only</a> 用法</p>
<h3 id="1-虚拟条件句"><a href="#1-虚拟条件句" class="headerlink" title="1. 虚拟条件句"></a>1. 虚拟条件句</h3><h4 id="1-1-表示与（现在、将来）事实相反的情况或可能性不大"><a href="#1-1-表示与（现在、将来）事实相反的情况或可能性不大" class="headerlink" title="1.1 表示与（现在、将来）事实相反的情况或可能性不大"></a>1.1 表示<strong>与（现在、将来）事实相反</strong>的情况或<strong>可能性不大</strong></h4><table>
<thead>
<tr>
<th>条件从句</th>
<th>主句</th>
</tr>
</thead>
<tbody><tr>
<td>过去式（通常 <strong>be-&gt;were</strong>）</td>
<td>would/might/could + <strong>do</strong></td>
</tr>
</tbody></table>
<p><em>If I <code>were</code> you, I<code>&#39;d plant</code> some trees round the house.</em> 如果我是你，我就会在房子周围种些树（你还没种，未来可能种）</p>
<p><em>If I <code>had</code> a map I <code>would lend</code> it to you.</em> 如果我有地图，我就借给你（但是我还没有，未来可能有）</p>
<p><em>If I <code>dyed</code> my hair blue everyone <code>would</code> laugh at me.</em>  如果我把我的头发染成蓝色（还没染，未来小概率染）</p>
<p><em>//从句用<code>If it were not for</code>，表示“若不是”</em></p>
<p><em>If <code>it weren&#39;t for</code> Ruth, you <code>wouldn&#39;t be</code> anywhere. //要不是Ruth，你不会有任何成就</em></p>
<p><em>If <code>it weren&#39;t for</code> your help, we <code>would be</code> in serious trouble.</em></p>
<h4 id="1-2-表示与过去事实相反"><a href="#1-2-表示与过去事实相反" class="headerlink" title="1.2 表示与过去事实相反"></a>1.2 表示与过去事实相反</h4><table>
<thead>
<tr>
<th>条件从句</th>
<th>主句</th>
</tr>
</thead>
<tbody><tr>
<td>If <strong>had done</strong></td>
<td>would/might/could/should <strong>have done</strong>**</td>
</tr>
</tbody></table>
<p><em>If anything <code>had happend</code>, he <code>would have</code> let us know.</em>  如果发生了什么，他<strong>早</strong>就通知我们了（没发生什么已经是事实了）</p>
<p><em>If Hanyu <code>had recieved</code> the present, she <code>should</code> have thanked me.</em>  如果HY收到了礼物（表明HY没有受到礼物已经是事实了），她早就谢谢我了</p>
<p><em>If I <code>had been</code> Nancy, I <code>wouldn&#39;t have</code> left him.</em> 如果我是南希，我不会离开他（南希已经离开了他）</p>
<p><code>had not been for</code> 表示 “要不是“</p>
<p><em>If it <code>hadn&#39;t been</code> for your timely help, we <code>would have</code> got into serious trouble.</em></p>
<h4 id="1-3-错综时间条件句"><a href="#1-3-错综时间条件句" class="headerlink" title="1.3 错综时间条件句"></a>1.3 错综时间条件句</h4><p>有些条件句主句谓语和从句谓语在时间上并不一致（不符合上述两点）</p>
<p><em>If you <code>had taken</code> her advice, you <code>wouldn&#39;t be</code> in such trouble now.</em></p>
<p><em>If he <code>were leaving</code>, you <code>should have</code> heard about it.</em></p>
<h4 id="1-4-含蓄条件句"><a href="#1-4-含蓄条件句" class="headerlink" title="1.4 含蓄条件句"></a>1.4 含蓄条件句</h4><p>隐含的条件句</p>
<p><em>I might see her personally, it <code>would be</code> better.</em></p>
<p><em>I did not press the point as it <code>would be</code> useless.</em></p>
<p><em>In the old days she <code>would have</code> argued.</em></p>
<p><em>I <code>wouldn&#39;t worry</code> about it.</em></p>
<h4 id="1-5-委婉客气的语气，情态动词的使用（should-would-could-might）"><a href="#1-5-委婉客气的语气，情态动词的使用（should-would-could-might）" class="headerlink" title="1.5 委婉客气的语气，情态动词的使用（should, would, could, might）"></a>1.5 委婉客气的语气，情态动词的使用（should, would, could, might）</h4><p><em><code>Would</code> you mind shutting the window?</em></p>
<p><em><code>Would</code> you tell me how to …</em></p>
<p><em><code>Could</code> you lend me your computer?</em></p>
<p><em>If necessary, you <code>might</code> shorten it.</em></p>
<h3 id="2-虚拟语气在某些从句中的应用"><a href="#2-虚拟语气在某些从句中的应用" class="headerlink" title="2. 虚拟语气在某些从句中的应用"></a>2. 虚拟语气在某些从句中的应用</h3><h4 id="2-1-宾语从句"><a href="#2-1-宾语从句" class="headerlink" title="2.1 宾语从句"></a>2.1 宾语从句</h4><ol>
<li><p><code>wish</code></p>
<p>a. 与<strong>现在</strong>事实相反（<strong>be-&gt;were</strong>），<strong>过去式</strong></p>
<p><em>I wish I <code>had</code> more time.</em>   还没有更多时间，但可能有</p>
<p><em>I wish I <code>could</code> help you.</em> 我希望我能帮你（还没帮，未来可能帮，I wish I had helped you. 我希望我已经帮你，没帮已经是过去的事实了）</p>
<p><em>I wish I <code>were</code>(was) young again.  // 用 was 也行</em></p>
<p>b. 与<strong>过去</strong>事实相反，<strong>过去完成时</strong>，常表示<strong>遗憾</strong></p>
<p><em>I wish I <code>had thought</code> what she really want.</em>  我没想过她真正想要什么，已经是事实了</p>
<p><em>I wish I <code>had restrained</code> my emotion.</em>  我没有控制我的情感，已经是事实了</p>
<p>c. 谈论<strong>将来</strong>的愿望，从句用 <code>would、could、might + do</code></p>
<p><em>I wish I <code>could</code> do something for you in return. 我希望我能做点什么回报你</em></p>
</li>
<li><p><code>would rather</code></p>
<p>谓语多用<strong>过去式</strong>，表<strong>现在、将来</strong></p>
<p><em>I’d rather you <code>told</code> me the truth.</em>  我宁愿你给我讲真话</p>
<p>suppose 虚拟+宾语从句（如果是对将来的假设，动词用过去时）</p>
<p><em>Suppose her father turned her out of doors!</em></p>
</li>
<li><p><code>suggest</code>、<code>demand</code>、<code>insist</code>、<code>ask</code>等表示要求、命令、建议一类的动词</p>
<p>从句用 <code>should + do</code>，但是 <code>should</code> 一般省略</p>
<p><em>The doctor advised that he <code>change</code> the job.</em></p>
<p><em>I propose that sb (should) <code>be</code> …</em></p>
<p><em>He commanded that we (should) <code>attack</code> at once.</em></p>
</li>
</ol>
<h4 id="2-2-主语从句、表语从句、同位语从句"><a href="#2-2-主语从句、表语从句、同位语从句" class="headerlink" title="2.2 主语从句、表语从句、同位语从句"></a>2.2 主语从句、表语从句、同位语从句</h4><p>从句用 <code>(should) do</code></p>
<p><strong>主语从句</strong></p>
<p><em>It’s important that he <code>work</code> hard.</em></p>
<p><em>It’s _________ you <code>(should) not be</code> seen here. // 你不该出现在这里，这很…</em></p>
<p><code>should do</code> 有时表达“竟然”的情感色彩</p>
<p><em>It seems so unfair that this <code>should happen</code> to me.</em></p>
<p><em>It’s strange that she <code>should be</code> so late. //真奇怪，她竟然来得这么晚</em></p>
<p><strong>表语从句</strong></p>
<p><em>Her idea was that they <code>should lock</code> up the house.</em></p>
<p><strong>同位语从句</strong></p>
<p><em>They expressed the wish that they <code>(should) be</code> given more free time.</em></p>
<h4 id="3-状语从句"><a href="#3-状语从句" class="headerlink" title="3. 状语从句"></a>3. 状语从句</h4><ul>
<li><p><code>as if</code>、<code>as though</code></p>
<p>表示<strong>现在</strong>情况用<strong>过去式</strong>，表示<strong>过去</strong>情况用<strong>过去完成形式</strong></p>
<p><em>I have loved you as if you <code>were</code> my son.</em></p>
<p><em>I remember it as if it <code>happened</code> last night.</em></p>
<p><em>He looks as though he <code>had known</code> Millie for years.</em> </p>
<p>在 <code>look</code>、<code>seem</code>、<code>taste</code>、<code>smell</code> 后，<code>as if</code> 引导的从句可用<strong>陈述</strong>语气，大概率事件</p>
<p><em>It looks as if they <code>are</code> in a terrible hurry.</em></p>
<p><em>The meat tastes as if it <code>has</code> gone bad.</em></p>
<p><code>as if (though)</code> 引导<strong>表语从句</strong></p>
<p><em>You look as if you <code>didn&#39;t</code> care.</em></p>
</li>
<li><p><strong>让步状语从句</strong></p>
<p><em>Whether she <code>be(is)</code> right or wrong, we will support her.</em></p>
</li>
<li><p><strong>目的状语</strong></p>
<p>从句谓语多用 would、should、could、might</p>
<p><em>I hired a boat so that I <code>could</code> go fish.</em></p>
<p><em>He left early in order that the children <code>would</code> not be alone in the house.</em></p>
</li>
<li><p><strong>be+形容词，should+动词原形</strong>（张道真认为形容词后的从句为状语从句，有些认为是宾语从句）</p>
<p><em>I’m <code>surprised</code> that you <code>should</code> press the suggestion. //我很奇怪你竟然坚持你的建议</em></p>
<p><em>They’re especially <code>anxious</code> that you <code>should</code> come.  //他们特别期盼你能来</em></p>
</li>
</ul>
<h3 id="虚拟语气的一些其他用法"><a href="#虚拟语气的一些其他用法" class="headerlink" title="虚拟语气的一些其他用法"></a>虚拟语气的一些其他用法</h3><p>只记录了较常见的</p>
<ul>
<li><p><code>It&#39;s (high) time</code> 后的定语从句中的虚拟语气</p>
<p>多用<strong>过去虚拟</strong>语气</p>
<p><em>It’s time we <code>went</code>.</em></p>
<p><em>It’s time we <code>were</code> leaving.</em></p>
<p><em>It’s high time you <code>made</code> up your mind.</em></p>
</li>
<li><p><code>would have thought</code></p>
<p><em>Who <code>would have thought</code> to see you here!  //谁能想到会在这里看到你！</em></p>
<p><em>Who <code>would have thought</code> it was going to break like that?</em>  </p>
</li>
</ul>
<p>参考资料：<a target="_blank" rel="noopener" href="https://book.douban.com/subject/1210225/">张道真实用英语语法</a></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2021/11/13/%E8%8B%B1%E8%AF%AD/%E8%99%9A%E6%8B%9F%E8%AF%AD%E6%B0%94%E4%B8%93%E9%A2%98/">
    <time datetime="2021-11-12T16:00:00.000Z" class="entry-date">
        2021-11-13
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/English/">English</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Grammar/" rel="tag">Grammar</a></li></ul>

    </footer>
</article>






  
    <article id="post-C++/STL/顺序容器/字符串输入" class="post-C++/STL/顺序容器/字符串输入 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2021/11/10/C++/STL/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5/">字符串输入这些麻烦事儿</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://example.com/2021/11/10/C++/STL/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5/" data-id="cl829min9002kssv50enehe0s" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h2 id="1-cin"><a href="#1-cin" class="headerlink" title="1. cin"></a>1. cin</h2><p><code>cin</code>使用<strong>空白</strong>（空格、制表符和换行符）来确定字符串的<strong>结束位置</strong>，<code>cin</code>只能读取一个单词，读取到空格就结束了，然后将读到的字符串放到数组中，并在结尾添加空字符<code>&#39;\0&#39;</code>。       </p>
<blockquote>
<p><code>cin</code>将换行符<strong>保留</strong>在输入队列中。</p>
</blockquote>
<h4 id="1-1-while-cin-用法"><a href="#1-1-while-cin-用法" class="headerlink" title="1.1 while(cin)用法"></a>1.1 while(cin)用法</h4><blockquote>
<p><code>istream</code> 类提供了一个可以将 <code>istream</code> 对象（如 <code>cin</code>）转换为 <code>bool</code> 值的函数。</p>
<p>当 <code>cin</code> 出现在需要 <code>bool</code> 值的地方（例如 <code>while</code> 条件中）<code>cin</code>将被转换为<code>bool</code>值。读取成功返回 <code>true</code>，否则就返回 <code>false</code>。</p>
</blockquote>
<p>常见用法如下：</p>
<ol>
<li><p>每次读取一个字符，直到遇到EOF</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>(ch);</span><br><span class="line"><span class="keyword">while</span>(cin)&#123;  <span class="comment">// 单飘一个cin，用来测试是否到文件尾了，当遇到文件结束符EOF时，终止</span></span><br><span class="line">    ...</span><br><span class="line">    cin.<span class="built_in">get</span>(ch);  <span class="comment">//如果读取没成功，会将失败标记置位</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin.<span class="built_in">get</span>(ch))&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>循环输入一组数字到<code>vector</code>，遇到换行符终止</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;num)&#123;</span><br><span class="line">    arr.<span class="built_in">push_back</span>(num);</span><br><span class="line">    <span class="keyword">if</span>(cin.<span class="built_in">get</span>()==<span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-cin-getline-、cin-get"><a href="#2-cin-getline-、cin-get" class="headerlink" title="2. cin.getline()、cin.get()"></a>2. cin.getline()、cin.get()</h2><h4 id="2-1-cin-getline"><a href="#2-1-cin-getline" class="headerlink" title="2.1 cin.getline()"></a>2.1 cin.getline()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(<span class="keyword">char</span>* s, streamsize n )</span></span>;</span><br></pre></td></tr></table></figure>

<p>遇到换行符停止读入，<u><strong>不保存</strong>换行符</u>，用空字符替代换行符，加到数组后面</p>
<p>接受两个参数</p>
<ol>
<li><p>第一个是要接受读进来的字符串的字符数组的地址</p>
</li>
<li><p>第二个是要读取的字符数 <code>n</code></p>
</li>
</ol>
<p>注意：<code>n</code> 不能超过字符数组的大小，且 <code>n</code> 已经计入了 <code>&#39;\0&#39;</code>，也就是说有效允许读入字符数应该是 <code>n-1</code></p>
<h4 id="2-2-cin-get"><a href="#2-2-cin-get" class="headerlink" title="2.2 cin.get()"></a>2.2 cin.get()</h4><p><code>cin.get()</code>有几种变体：</p>
<ol>
<li><p>接受的参数与<code>cin.getline()</code>一样，但是<strong>保留换行符在输入队列中</strong>（和<code>cin</code>一样）</p>
</li>
<li><p>不带任何参数</p>
<p><code>cin.get();</code> 它可用来读取<strong>下一个字符</strong>（可以是换行符）</p>
</li>
<li><p>带一个char参数，读取下一个字符到<code>_Ch</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>(<span class="keyword">char</span> &amp;_Ch)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-string类成员函数getline"><a href="#3-string类成员函数getline" class="headerlink" title="3. string类成员函数getline()"></a>3. string类成员函数getline()</h2><p>读取一整行，直到遇到<strong>换行符</strong>（换行符也被读入，但是抛弃它，<strong>不存</strong>）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str;</span><br><span class="line"><span class="built_in">getline</span>(cin,str);</span><br></pre></td></tr></table></figure>


      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2021/11/10/C++/STL/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5/">
    <time datetime="2021-11-09T16:00:00.000Z" class="entry-date">
        2021-11-10
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E8%8F%9C/">我为什么这么菜~~</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/" rel="tag">C&#x2F;C++</a></li></ul>

    </footer>
</article>






  
  
    <nav id="pagination">
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/8/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span>
      </nav>
    </nav>
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-content">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/English/">English</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E8%8F%9C/">我为什么这么菜~~</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="category-list-count">1</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2022/09/12/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/">第一篇博客</a>
          </li>
        
          <li>
            <a href="/2022/09/12/%E8%93%9D%E5%9B%BE%E4%B8%8EC++%E4%BA%A4%E4%BA%92/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/09/12/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%81/%E9%9A%8F%E6%9C%BA%E6%89%93%E4%B9%B1%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E7%AE%97%E6%B3%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/09/12/%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-content">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/" rel="tag">C&#x2F;C++</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Grammar/" rel="tag">Grammar</a><span class="tag-list-count">3</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-content tagcloud">
      <a href="/tags/C-C/" style="font-size: 10px;">C/C++</a> <a href="/tags/Grammar/" style="font-size: 20px;">Grammar</a>
    </div>
  </aside>

  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2022 pano
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>